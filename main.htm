<!doctype html><meta charset=utf-8>
<style>
*{font-family:sans-serif}
h2{padding:10px;margin:0}
input~input[type=text] {width:40px}
input[type=checkbox]{vertical-align:-10%;margin:0px 5px}
input[type=number]{width:50px}
#sidebar {width:300px;background:#ddf}
video{max-width:100%;transform:scaleX(-1)}
canvas{max-width:100%; max-height:320px}
svg{position:fixed; left:320px; top:10px;}
form{padding:5px; line-height:2em}
#msgbox{position:fixed; left:320px; bottom:20px; padding:6px}
#msgbox:not(:empty) {background:rgba(255,255,255,0.8); }
#webcam{display:none}
button{cursor:pointer; border:0;padding:5px 10px;background:#aaa; margin:0 20px}
#tabbar {background:#ccc;}
#tabbar button{margin:0}
button{background:#ccc;outline:none;font-weight:bold;color:#333;}
button:hover{background:#666 !important;color:#fff}
#tabbar button.active{background:#999}
#imgselect,#webcam {text-align:justify;text-align-last:justify;}
#algoSelect{background:#eee;margin:5px 0}
canvas{ /* checkerboard pattern */ 
  background-color: #f8f8f8;
  background-image: 
    linear-gradient(45deg, #e0e0e0 25%, transparent 25%, transparent 75%, #e0e0e0 75%, #e0e0e0),
    linear-gradient(45deg, #e0e0e0 25%, transparent 25%, transparent 75%, #e0e0e0 75%, #e0e0e0);
  background-size: 40px 40px;
  background-position: 0 0, 20px 20px;
}
</style>

<div id=sidebar>

<h2>Plotterfun</h2>

<div id=tabbar>
<button id=tab1 onclick='tabImage()'>Image</button><button id=tab2 onclick='tabWebcam()'>Webcam</button>
</div>
<div id=imgselect>
<form>
Canvas
W:<input id=pcw type=number min=10 value=800 oninput='changeSize()'>
H:<input id=pch type=number min=10 value=600 oninput='changeSize()'>
</form>
<canvas></canvas><br>
<button onclick='selectImage()'>Select image</button>
<button onclick='useImage()'>Use image</button>
</div>
<div id=webcam>
<video autoplay></video>
<button onclick='video.paused?video.play():video.pause()'>Pause</button>
<button onclick='snapshot()'>Use image</button>
</div>

<form id=algoSelect>
Algorithm: 
<select id=algorithm onchange='loadWorker(this.value)'>
<option value=squiggle.js>Squiggle</option>
<option value=squiggleLeftRight.js>Squiggle Left/Right</option>
<option value=spiral.js>Spiral</option>
<option value=polyspiral.js>Polygon Spiral</option>
<option value=sawtooth.js>Sawtooth</option>
<option value=stipple.js>Stipples</option>
<option value=linedraw.js>Linedraw</option>
</select>
</form>
<form id=algoParams></form>

<button style='font-size:large; margin:10px' onclick=download()>Download SVG</button>
</div>

<svg></svg>

<div id=msgbox></div>

<script src=external/stackblur.min.js></script>
<script>
preview=document.querySelector("canvas")
prectx=preview.getContext("2d")
svg=document.querySelector('svg');
video=document.querySelector('video');
canvas=document.createElement("canvas")
ctx=canvas.getContext("2d")

config = {};

img = null;
scale = 1;
offset = [0,0]

// TODO
// upload to server option - pipe to hpgl python script or smoething


function changeSize(){
  cw = parseInt(pcw.value)
  ch = parseInt(pch.value)
  preview.width=cw
  preview.height=ch
  draw()
}
changeSize()

function tabImage(){
  if (video.srcObject && video.srcObject.getTracks().length) video.srcObject.getTracks()[0].stop()

  webcam.style.display='none'
  imgselect.style.display='block'
  tab1.className='active'
  tab2.className=''
}
tabImage()

function selectImage(){
  let d= document.createElement('input')
  d.type='file'
  d.onchange=function(e){
    img = new Image();
    img.onload=function(){
      let w=img.width, h=img.height;

      cw=parseInt(pcw.defaultValue) // reset size - worth it?

      if (w>cw || h>ch) { ch=Math.round(cw*h/w) }
      else if (w>10&&h>10){ch=h;cw=w}
      preview.height = pch.value = ch 
      preview.width = pcw.value = cw

      scale = Math.min(ch/h, cw/w)
      offset = [ cw/2, ch/2 ]
      draw()
    }
    img.src = URL.createObjectURL(e.target.files[0]);
  }
  d.click()
}
function draw(){
  if (!img) return
  prectx.clearRect(0,0,cw,ch)
  prectx.drawImage(img, offset[0]-scale*img.width*0.5,offset[1]-scale*img.height*0.5, scale*img.width, scale*img.height)
}
preview.onmousedown=function(e){
  let dx=e.clientX, dy=e.clientY
  let csc = cw / preview.getBoundingClientRect().width

  document.onmousemove=function(e){
    let x=e.clientX-dx, y=e.clientY-dy
    offset[0] += x*csc
    offset[1] += y*csc
    dx=e.clientX
    dy=e.clientY
    draw()
    return false
  }
  document.onmouseup=function(){
    document.onmousemove=null
    document.onmouseup=null
  }
  return false
}
preview.onwheel=function(e){
  scale *= e.deltaY>0 ?1.1:0.9;
  draw()
  return false;
}

function tabWebcam(){
  if (!navigator.mediaDevices || !navigator.mediaDevices.getUserMedia) {
    alert("could not open webcam");
  } else 
    navigator.mediaDevices.getUserMedia({video: true}).then(function(v) {
      video.srcObject = v;
      webcam.style.display='block'
      imgselect.style.display='none'
      tab2.className='active'
      tab1.className=''
    }).catch(function(e){console.log(e); alert("error opening webcam")});
}

var imageset = false;
function snapshot(){
  imageset=true;
  // config width height should come from sliders maybe?
  [canvas.width, canvas.height] = [video.videoWidth, video.videoHeight];
  ctx.drawImage(video, 0, 0)
  process()
}
function useImage(){
  if (!img) return
  imageset=true;
  [canvas.width, canvas.height] = [cw, ch];
  ctx.fillStyle='#fff'
  ctx.fillRect(0,0,cw,ch)
  ctx.drawImage(preview, 0,0)
  process()
}

function process(){
  if (!imageset) return;
  [config.width, config.height] = [canvas.width, canvas.height]
  loadWorker(window.algo)
  myWorker.postMessage([ window.config, ctx.getImageData(0,0,config.width,config.height) ]);
}
function ctrlChange(control){
  if (!imageset) return;
  if (!control.noRestart) 
    process()
  else
    myWorker.postMessage([ window.config ]);
}
function addController(control, form){
  if (!control.type) control.type = "range"
  let s = document.createElement("input")
  Object.assign(s, control)
  let l = document.createElement('label')
  let p = document.createElement('div')

  // Don't reset values when reloading controls with same name
  if (config[control.label]) control.value = config[control.label];
  else config[control.label] = control.value;

  if (control.type=='select') {
    s = document.createElement('select')
    s.oninput=e=>{config[control.label] = s.value; ctrlChange(control)}
    for (let i in control.options) {
      s.append(new Option( control.options[i], control.options[i], i==0, i==0 ))
    }
    l.append(control.label+': ')
    l.append(s)
    form.append(l)
    return
  } else if (control.type=='checkbox') {
    s.oninput=e=>{config[control.label] = s.checked; ctrlChange(control)}
    config[control.label] = s.checked
    l.append(s)  
  } else {
    let n = document.createElement('input')
    n.type="text" // type=number does not allow fractions
    n.pattern="\-?[0-9]+\.?[0-9]*"
    s.oninput=e=>{config[control.label] = Number( n.value = s.value ); ctrlChange(control)}
    n.oninput=e=>{config[control.label] = Number( s.value = n.value ); ctrlChange(control)}
    s.value = n.value = config[control.label] //.assign already set value, but value has to be set after min/max are set
    p.append(s);
    p.append(n)
  }
  l.append(control.label)
  l.append(p)
  form.append(l)

}

function loadWorker(src){
  if (window.myWorker) myWorker.terminate()
  window.myWorker = new Worker(src);
  msgbox.innerHTML = "";
  myWorker.onmessage = function(msg) {
    let [type, data] = msg.data

    // setup, declare parameters
    if (type == 'sliders') {
      if (src==window.algo) return;
      window.algo=src
      algoParams.innerHTML="";
      data.forEach(c=>addController( c, algoParams ))
      process()

    // message, e.g. progress bar
    } else if (type == 'msg') {
      msgbox.innerHTML = data;

    } else if (type == 'dbg'){
      window.data = data
      console.log(data) 

    // vector data result
    } else {
      resetSVG()
      if (type == 'points') {
        // either a list of points, or a list of lists of points
        if (typeof data[0][0] !== "object") data = [data]

        if (data[0][0].x) data.forEach(addPathNamed)
        else data.forEach(addPathArray)

      } else if (type == 'circles') {
        if (data[0].x) data.forEach(addCircleNamed)
        else data.forEach(addCircleArray)
      }

    } 
  }
}

const svgNS = "http://www.w3.org/2000/svg"
function resetSVG(){
  // erase existing contents
  let c; while (c = svg.firstChild) svg.removeChild(c)
  svg.setAttribute("width",config.width)
  svg.setAttribute("height",config.height)
  svg.setAttribute("viewbox", `0 0 ${config.width} ${config.height}`)
  svg.style.background=config.Inverted?"black":"white";
}
function addPathNamed(points){
  var pathstring = `M${points[0].x.toFixed(2)},${points[0].y.toFixed(2)} `;
  for (let i=1;i<points.length;i++) pathstring+=`L${points[i].x.toFixed(2)},${points[i].y.toFixed(2)}`;
  addPath(pathstring)
}
function addPathArray(points){
  var pathstring = `M${points[0][0].toFixed(2)},${points[0][1].toFixed(2)} `;
  for (let i=1;i<points.length;i++) pathstring+=`L${points[i][0].toFixed(2)},${points[i][1].toFixed(2)}`;
  addPath(pathstring)
}
function addPath(pathstring){
  var p=document.createElementNS(svgNS, "path");
  p.setAttributeNS(null, "style", "stroke-width: 2px; fill: none; stroke: " + (config.Inverted?"white":"black"))
  p.setAttributeNS(null, "d", pathstring) 
  svg.appendChild(p)
}
function addCircleNamed(d) { addCircleArray([d.x,d.y,d.r])}
function addCircleArray(d){
  var p=document.createElementNS(svgNS, "circle");
  p.setAttributeNS(null, "style", "fill: " + (config.Inverted?"white":"black"))
  p.setAttributeNS(null, "cx", d[0]) 
  p.setAttributeNS(null, "cy", d[1]) 
  p.setAttributeNS(null, "r",  d[2]) 
  svg.appendChild(p)
}

function download(){
  const svgString = '<?xml version="1.0" standalone="no"?><!DOCTYPE svg PUBLIC "-//W3C//DTD SVG 1.1//EN" "http://www.w3.org/Graphics/SVG/1.1/DTD/svg11.dtd">'
    + (new XMLSerializer()).serializeToString(svg);
  const blob = new Blob([svgString], {type: 'image/svg+xml;charset=utf-8'});

  const downloadLink = document.createElement("a");
  downloadLink.href = URL.createObjectURL(blob);
  downloadLink.download = window.algo.replace('.js','_') + Date.now() + ".svg";
  document.body.appendChild(downloadLink);
  downloadLink.click();
  document.body.removeChild(downloadLink);
}

algorithm.onchange()


</script>
