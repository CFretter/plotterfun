<!doctype html><meta charset=utf-8>
<style>
*{font-family:sans-serif}
#controls input[type=text] {width:30px}
#sidebar {width:300px;background:#ddf}
video{max-width:100%;transform:scaleX(-1)}
svg{position:fixed; left:320px; top:10px;}
form{padding:5px; line-height:2em}
</style>

<div id=sidebar>


<div id=webcam>
<video autoplay></video>
<button onclick='video.paused?video.play():video.pause()'>Pause</button>
<button onclick='snapshot()'>Use image</button>
</div>


Algorithm: 
<select id=algorithm onchange='loadWorker(this.value)'>
<option value=squiggle.js>Squiggle</option>
<option value=squiggleLeftRight.js>Squiggle Left/Right</option>
<option value=spiral.js>Spiral</option>
<option value=polyspiral.js>Polygon Spiral</option>
<option value=sawtooth.js>Sawtooth</option>
<option value=stipple.js>Stippletest</option>
</select>

<form id=controls></form>

<button onclick=download()>Download SVG</button>
</div>

<svg></svg>

<script>
svg=document.querySelector('svg');
video=document.querySelector('video');
canvas=document.createElement("canvas")
ctx=canvas.getContext("2d")

config = {};

// TODO
// normal image selection
// width/height controls, resize webcam keeping aspect ratio
// upload to server option - pipe to hpgl python script or smoething


navigator.mediaDevices.getUserMedia({video: true}).then(function(v) {
  video.srcObject = v;
//  video.onplay=function(){process()}
}).catch(function(e){console.log(e)});

var imageset = false;
function snapshot(){
  imageset=true;
  // config width height should come from sliders maybe?
  [canvas.width, canvas.height] = [video.videoWidth, video.videoHeight];
  ctx.drawImage(video, 0, 0)
  process()
}

function process(){
  if (!imageset) return;
  [config.width, config.height] = [canvas.width, canvas.height]
  loadWorker(window.algo)
  myWorker.postMessage([ window.config, ctx.getImageData(0,0,config.width,config.height) ]);
}


function loadWorker(src){
  if (window.myWorker) myWorker.terminate()
  window.myWorker = new Worker(src);
  myWorker.onmessage = function(msg) {
    let [type, data] = msg.data

    // setup, declare parameters
    if (type == 'sliders') {
      if (src==window.algo) return;
      controls.innerHTML="";
  
      data.forEach(slider=>{
        let s = document.createElement("input")
        s.type="range"
        Object.assign(s, slider)
        let n = document.createElement('input')
        n.type="text" // type=number does not allow fractions
        n.pattern="\-?[0-9]+\.?[0-9]*"
        let l = document.createElement('label')
        let p = document.createElement('div')

        // Don't reset values when reloading controls with same name
        if (config[slider.label]) slider.value = config[slider.label];
        else config[slider.label] = slider.value;

        s.value = n.value = config[slider.label] //.assign already set value, but value has to be set after min/max are set

        if (slider.type && slider.type=='checkbox') {
          s.oninput=e=>{config[slider.label] = s.checked; process()}
          l.append(s)  
        } else {
          s.oninput=e=>{config[slider.label] = Number( n.value = s.value ); process()}
          n.oninput=e=>{config[slider.label] = Number( s.value = n.value ); process()}
          p.append(s);
          p.append(n)
        }
        l.append(slider.label)
        l.append(p)
        controls.append(l)

      })
    window.algo=src
    process()
  
    // message, e.g. progress bar
    } else if (type == 'msg') {
  
  
    // vector data result
    } else {

      svg.style.background=config.Inverted?"black":"white";
      // erase existing contents
      let c; while (c = svg.firstChild) svg.removeChild(c)
      svg.setAttribute("width",config.width)
      svg.setAttribute("height",config.height)
      svg.setAttribute("viewbox", `0 0 ${config.width} ${config.height}`)

      if (type == 'points') {
        // either a list of points, or a list of lists of points
        if (typeof data[0][0] === "number") data = [data]
        data.forEach(path => addPath(path))
      } else if (type == 'circles') {
        data.forEach(addCircle)
      }

    } 
  }
}

const svgNS = "http://www.w3.org/2000/svg"
function addPath(points){
  var pathstring = `M${points[0][0].toFixed(2)},${points[0][1].toFixed(2)} `;
  for (let i=1;i<points.length;i++) pathstring+=`L${points[i][0].toFixed(2)},${points[i][1].toFixed(2)}`;

  var p=document.createElementNS(svgNS, "path");
  p.setAttributeNS(null, "style", "stroke-width: 2px; fill: none; stroke: " + (config.Inverted?"white":"black"))
  p.setAttributeNS(null, "d", pathstring) 
  svg.appendChild(p)
}

function addCircle(d){
  var p=document.createElementNS(svgNS, "circle");
  p.setAttributeNS(null, "style", "fill: " + (config.Inverted?"white":"black"))
  p.setAttributeNS(null, "cx", d[0]) 
  p.setAttributeNS(null, "cy", d[1]) 
  p.setAttributeNS(null, "r",  d[2]) 
  svg.appendChild(p)
}

function download(){
  const svgString = '<?xml version="1.0" standalone="no"?><!DOCTYPE svg PUBLIC "-//W3C//DTD SVG 1.1//EN" "http://www.w3.org/Graphics/SVG/1.1/DTD/svg11.dtd">'
    + (new XMLSerializer()).serializeToString(svg);
  const blob = new Blob([svgString], {type: 'image/svg+xml;charset=utf-8'});

  const downloadLink = document.createElement("a");
  downloadLink.href = URL.createObjectURL(blob);
  downloadLink.download = window.algo.replace('.js','_') + Date.now() + ".svg";
  document.body.appendChild(downloadLink);
  downloadLink.click();
  document.body.removeChild(downloadLink);
}

algorithm.onchange()


</script>
