<!doctype html><meta charset=utf-8>
<style>
*{font-family:sans-serif}
input~input[type=text] {width:40px}
#sidebar {width:300px;background:#ddf}
video{max-width:100%;transform:scaleX(-1)}
svg{position:fixed; left:320px; top:10px;}
form{padding:5px; line-height:2em}
#msgbox{position:fixed; left: 320px; bottom:20px}
</style>

<div id=sidebar>


<div id=webcam>
<video autoplay></video>
<button onclick='video.paused?video.play():video.pause()'>Pause</button>
<button onclick='snapshot()'>Use image</button>
</div>

<form>
Algorithm: 
<select id=algorithm onchange='loadWorker(this.value)'>
<option value=squiggle.js>Squiggle</option>
<option value=squiggleLeftRight.js>Squiggle Left/Right</option>
<option value=spiral.js>Spiral</option>
<option value=polyspiral.js>Polygon Spiral</option>
<option value=sawtooth.js>Sawtooth</option>
<option value=stipple.js>Stipples</option>
<option value=linedraw.js>Linedraw</option>
</select>
</form>
<form id=imageParams></form>
<form id=algoParams></form>

<button onclick=download()>Download SVG</button>
</div>

<svg></svg>

<div id=msgbox></div>

<script src=external/stackblur.min.js></script>
<script>
svg=document.querySelector('svg');
video=document.querySelector('video');
canvas=document.createElement("canvas")
ctx=canvas.getContext("2d")

config = {};

[
  {label: 'Inverted', type:'checkbox'},
  {label: 'Brightness', value: 0, min: -100, max: 100},
  {label: 'Contrast', value: 0, min: -100, max: 100},
  {label: 'Min brightness', value: 0, min: 0, max: 255},
  {label: 'Max brightness', value: 255, min: 0, max: 255},
].forEach(c => addController(c, imageParams))

// TODO
// normal image selection
// width/height controls, resize webcam keeping aspect ratio
// upload to server option - pipe to hpgl python script or smoething


if (1 || !navigator.mediaDevices) {
  video = new Image()
  video.src='lenna.png'
  video.onload=()=>{video.videoWidth=video.width;video.videoHeight=video.height}
} else 
navigator.mediaDevices.getUserMedia({video: true}).then(function(v) {
  video.srcObject = v;
//  video.onplay=function(){process()}
}).catch(function(e){console.log(e)});

var imageset = false;
function snapshot(){
  imageset=true;
  // config width height should come from sliders maybe?
  [canvas.width, canvas.height] = [video.videoWidth, video.videoHeight];
  ctx.drawImage(video, 0, 0)
//  StackBlur.canvasRGB(canvas, 0,0,canvas.width,canvas.height,1) // small amount of blur to eliminate noise
  process()
}

function process(){
  if (!imageset) return;
  [config.width, config.height] = [canvas.width, canvas.height]
  loadWorker(window.algo)
  myWorker.postMessage([ window.config, ctx.getImageData(0,0,config.width,config.height) ]);
}
function ctrlChange(control){
  if (!imageset) return;
  if (!control.noRestart) 
    process()
  else
    myWorker.postMessage([ window.config ]);
}
function addController(control, form){
  if (!control.type) control.type = "range"
  let s = document.createElement("input")
  Object.assign(s, control)
  let l = document.createElement('label')
  let p = document.createElement('div')

  // Don't reset values when reloading controls with same name
  if (config[control.label]) control.value = config[control.label];
  else config[control.label] = control.value;

  if (control.type=='checkbox') {
    s.oninput=e=>{config[control.label] = s.checked; ctrlChange(control)}
    config[control.label] = s.checked
    l.append(s)  
  } else {
    let n = document.createElement('input')
    n.type="text" // type=number does not allow fractions
    n.pattern="\-?[0-9]+\.?[0-9]*"
    s.oninput=e=>{config[control.label] = Number( n.value = s.value ); ctrlChange(control)}
    n.oninput=e=>{config[control.label] = Number( s.value = n.value ); ctrlChange(control)}
    s.value = n.value = config[control.label] //.assign already set value, but value has to be set after min/max are set
    p.append(s);
    p.append(n)
  }
  l.append(control.label)
  l.append(p)
  form.append(l)

}

function loadWorker(src){
  if (window.myWorker) myWorker.terminate()
  window.myWorker = new Worker(src);
  msgbox.innerHTML = "";
  myWorker.onmessage = function(msg) {
    let [type, data] = msg.data

    // setup, declare parameters
    if (type == 'sliders') {
      if (src==window.algo) return;
      window.algo=src
      algoParams.innerHTML="";
      data.forEach(c=>addController( c, algoParams ))
      process()
    // message, e.g. progress bar
    } else if (type == 'msg') {
      msgbox.innerHTML = data;
    } else if (type == 'dbg'){
      //window.data = data;
      //console.log(data)

      let id = new Uint8ClampedArray(config.width*config.height*4)
      for (let i=0;i<data.length;i++) {
        id[i*4+0] = 
        id[i*4+1] = 
        id[i*4+2] = data[i]
        id[i*4+3] = 255
      }
      dbgcanvas.width=config.width
      dbgcanvas.height=config.height
      dbgctx.putImageData(new ImageData(id,config.width,config.height),0,0)

    // vector data result
    } else {
      resetSVG()
      if (type == 'points') {
        // either a list of points, or a list of lists of points
        if (typeof data[0][0] !== "object") data = [data]

        if (data[0][0].x) data.forEach(addPathNamed)
        else data.forEach(addPathArray)

      } else if (type == 'circles') {
        if (data[0].x) data.forEach(addCircleNamed)
        else data.forEach(addCircleArray)
      }

    } 
  }
}

const svgNS = "http://www.w3.org/2000/svg"
function resetSVG(){
  // erase existing contents
  let c; while (c = svg.firstChild) svg.removeChild(c)
  svg.setAttribute("width",config.width)
  svg.setAttribute("height",config.height)
  svg.setAttribute("viewbox", `0 0 ${config.width} ${config.height}`)
  svg.style.background=config.Inverted?"black":"white";
}
function addPathNamed(points){
  var pathstring = `M${points[0].x.toFixed(2)},${points[0].y.toFixed(2)} `;
  for (let i=1;i<points.length;i++) pathstring+=`L${points[i].x.toFixed(2)},${points[i].y.toFixed(2)}`;
  addPath(pathstring)
}
function addPathArray(points){
  var pathstring = `M${points[0][0].toFixed(2)},${points[0][1].toFixed(2)} `;
  for (let i=1;i<points.length;i++) pathstring+=`L${points[i][0].toFixed(2)},${points[i][1].toFixed(2)}`;
  addPath(pathstring)
}
function addPath(pathstring){
  var p=document.createElementNS(svgNS, "path");
  p.setAttributeNS(null, "style", "stroke-width: 2px; fill: none; stroke: " + (config.Inverted?"white":"black"))
  p.setAttributeNS(null, "d", pathstring) 
  svg.appendChild(p)
}
function addCircleNamed(d) { addCircleArray([d.x,d.y,d.r])}
function addCircleArray(d){
  var p=document.createElementNS(svgNS, "circle");
  p.setAttributeNS(null, "style", "fill: " + (config.Inverted?"white":"black"))
  p.setAttributeNS(null, "cx", d[0]) 
  p.setAttributeNS(null, "cy", d[1]) 
  p.setAttributeNS(null, "r",  d[2]) 
  svg.appendChild(p)
}

function download(){
  const svgString = '<?xml version="1.0" standalone="no"?><!DOCTYPE svg PUBLIC "-//W3C//DTD SVG 1.1//EN" "http://www.w3.org/Graphics/SVG/1.1/DTD/svg11.dtd">'
    + (new XMLSerializer()).serializeToString(svg);
  const blob = new Blob([svgString], {type: 'image/svg+xml;charset=utf-8'});

  const downloadLink = document.createElement("a");
  downloadLink.href = URL.createObjectURL(blob);
  downloadLink.download = window.algo.replace('.js','_') + Date.now() + ".svg";
  document.body.appendChild(downloadLink);
  downloadLink.click();
  document.body.removeChild(downloadLink);
}

algorithm.onchange()

/// debug
dbgcanvas = document.createElement("canvas")
dbgctx=dbgcanvas.getContext("2d")
document.body.append(dbgcanvas)

</script>

<style>canvas{position:fixed; right:10px; top:10px; }</style>
